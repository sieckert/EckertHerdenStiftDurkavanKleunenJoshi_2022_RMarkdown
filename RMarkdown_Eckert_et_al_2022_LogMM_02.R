#' ---
#' title: <center><b>Markdown document from&colon;</b><br>Traces of Genetic but Not Epigenetic Adaptation in the Invasive Goldenrod _Solidago canadensis_ Despite the Absence of Population Structure</center>
#' pagetitle: RMarkdown document from:&nbsp;Eckert&nbsp;et&nbsp;al.&nbsp;(2022)
#' subtitle: <center>doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.3389/fevo.2022.856453">10.3389/fevo.2022.856453</a></center>
#' author: <center>Eckert, S., Herden, J., Stift, M., Durka, W., van Kleunen, M., & Joshi, J.</center>
#' date: <center>`r Sys.Date()`</center>
#' abstract: <p align="justify">This RMarkdown script belongs
#'   to a series of scripts generated by Silvia Eckert as part of
#'   the statistical analysis for the above-mentioned manuscript.
#'   The data underlying the applied R code can be found in the ZENODO
#'   repository and contains genetic (AFLP) and epigenetic (MSAP) markers
#'   from offspring of 25 _Solidago canadensis_ populations sampled along a
#'   latitudinal gradient in Central Europe. This particular RMarkdown script
#'   is part 02/03 and applies logistic mixed-effects models on AFLP and MSAP datasets. <b>Please cite this
#'   script as follows:</b></p><br><p>Eckert, S., Herden, J.,
#'   Stift, M., Durka, W., van Kleunen, M., & Joshi, J. (2022). Data From&colon;
#'   Traces of Genetic but Not Epigenetic Adaptation in the Invasive
#'   Goldenrod _Solidago canadensis_ Despite the Absence of Population
#'   Structure. _Zenodo_. doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.5281/zenodo.6388135">10.5281/zenodo.6388135</a></center></p>
#' geometry: margin=2cm
#' output:
#'   html_document:
#'      code_folding: show
#'      keep_md: FALSE
#'      theme: flatly
#'      highlight: textmate
#'      df_print: paged
#'      toc: true
#'      toc_float: true
#' ---
#' 

#'
#'```{r setup, include = FALSE}
#'knitr::opts_chunk$set(eval=FALSE, cache=FALSE, warning=FALSE)
#'```

#' # Packages
#' <a href="#top">Back to top</a>
#+ project_packages, results='hide', message=FALSE, warning=FALSE
########### packages ...................... ####
# install.packages("name_of_package") # install necessary packages
# install knitr to save this script as html output using RStudio with Ctrl+Shift+K (Windows & Linux) or Command+Shift+K (macOS)
# install.packages("knitr") 
# getwd() # get current working directory
# setwd() # set working directory
# create folder for datasets to be stored to get this RMarkdown script running
dir.create("./data",
           showWarnings=F)
# add necessary libraries
library(lme4)
library(ggplot2)
library(cowplot)
library(tibble)
library(dplyr)
library(xlsx)
library(ImportExport)
library(sjmisc)
library(ggeffects)
library(tidyverse)
library(broom)
library(broom.mixed)
library(MuMIn)
library(easystats)

#' # Load data
#' <a href="#top">Back to top</a>
#+ project_load.data
########### load data ....................... ####
# load AFLP/MSAP data
source("RMarkdown_Eckert_et_al_2022_loadMolecularData.R")

#' ## PCA
#' <a href="#top">Back to top</a>
#+ project_distances.pca
######## WorldClim PCA ####
PCA_axes <- tibble(read.table("./data/Data_PCA_WorldClim.txt",
                              header=T)); PCA_axes
colnames(PCA_axes)[4] <- "latitude" # re-label for merging

#' ## Outlier
#+ project_load.outlier
######## Outlier loci ####
# climate
# loc58 (AFLP), loc286 (AFLP), loc189 (MSAP-m)
autocorr_candidates <- tibble(read.table('./data/Data_OutlierScan_Autocorr_intersection.txt',
                                         header=T)); autocorr_candidates

#' # Loc282 (MSAPm)
#' <a href="#top">Back to top</a>
#+ project_model.loc282
########### Loc282 (MSAPm) ......... ####
autocorr_candidates; autocorr_candidates[[1,2]]
# extract from AFLP data
df_LogMM_loc282 <- data.frame(loc282 = MSAPm[,autocorr_candidates[[1,2]]],
                              block = MSAPm$common_garden_block,
                              treatment = MSAPm$treatment,
                              latitude = MSAPm$lat,
                              populationID = MSAPm$populationID,
                              maternal_line = MSAPm$maternal_line); tibble(df_LogMM_loc282)
# add PCA axes
df_LogMM_loc282 <- tibble(merge(df_LogMM_loc282,
                                MEMGENEs,
                                by="latitude")); df_LogMM_loc282
# find minimum to shift values into positive space for model convergence
loc282_minValue <- abs(min(c(scale(df_LogMM_loc282$MEMGENE1),
                             scale(df_LogMM_loc282$MEMGENE2),
                             scale(df_LogMM_loc282$MEMGENE3)))) + 0.1; loc282_minValue
# add transformed MEMGENE variables
df_LogMM_loc282$MEMG1_rescaled <- scale(df_LogMM_loc282$MEMGENE1)+loc282_minValue
df_LogMM_loc282$MEMG2_rescaled <- scale(df_LogMM_loc282$MEMGENE2)+loc282_minValue
df_LogMM_loc282$MEMG3_rescaled <- scale(df_LogMM_loc282$MEMGENE3)+loc282_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc282$pop_ind <- paste0(df_LogMM_loc282$maternal_line, '_',
                                  df_LogMM_loc282$populationID)
# change variables to factors
df_LogMM_loc282$pop_ind <- as.factor(df_LogMM_loc282$pop_ind)
df_LogMM_loc282

#' ## Model
#' <a href="#top">Back to top</a>
#+ project_model.loc282.glmer_model
########### Model ####
# logistic mixed effects model
logMM.loc282 <- glmer(loc282 ~
                        MEMG1_rescaled +
                        treatment +
                        MEMG1_rescaled:treatment +
                        MEMG2_rescaled +
                        MEMG2_rescaled:treatment +
                        MEMG3_rescaled +
                        MEMG3_rescaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link = "logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc282)
summary(logMM.loc282); AICc(logMM.loc282)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc282.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc282_BoxTidwell <- glmer(loc282 ~
                                   # fixed factors in model:
                                   MEMG1_rescaled +
                                   treatment +
                                   MEMG1_rescaled:treatment +
                                   MEMG2_rescaled +
                                   MEMG2_rescaled:treatment +
                                   MEMG3_rescaled +
                                   MEMG3_rescaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   MEMG1_rescaled:log(MEMG1_rescaled) +
                                   MEMG2_rescaled:log(MEMG2_rescaled) +
                                   MEMG3_rescaled:log(MEMG3_rescaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 # settings:
                                 family=binomial(link = "logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc282); summary(logMM.loc282_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10.)
# check for model without interaction terms
logMM.loc282_noInteractions <- update(logMM.loc282,
                                      .~.-MEMG1_rescaled:treatment
                                      -MEMG2_rescaled:treatment
                                      -MEMG3_rescaled:treatment)
# check removal
summary(logMM.loc282_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc282)
# check multicollinearity without interactions
check_collinearity(logMM.loc282_noInteractions)
# 4. check for influential values (takes 15 minutes)
logMM.loc282_inf <- influence.ME::influence(logMM.loc282,
                                            obs=T,
                                            delete=T); logMM.loc282_inf
logMM.loc282_cooks <- influence.ME::cooks.distance.estex(logMM.loc282_inf); logMM.loc282_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc282_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc282.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc282_evalX <- drop1(logMM.loc282,
                            test="Chisq"); logMM.loc282_evalX
# remove interactions
logMM.loc282_main <- update(logMM.loc282,
                            .~. -lat_scaled:treatment-
                              MEMG1_rescaled:treatment-
                              MEMG2_rescaled:treatment-
                              MEMG3_rescaled:treatment); summary(logMM.loc282_main)
# evaluate main model without interactions
logMM.loc282_evalmain <- drop1(logMM.loc282_main,
                               test="Chisq"); logMM.loc282_evalmain

#' # Loc176 (MSAPu)
#' <a href="#top">Back to top</a>
#+ project_model.loc176
########### Loc176 (MSAPu) .......... ####
autocorr_candidates; autocorr_candidates[[1,3]]
# extract from AFLP data
df_LogMM_loc176 <- data.frame(loc176 = MSAPn[,autocorr_candidates[[1,3]]],
                              block = MSAPn$common_garden_block,
                              treatment = MSAPn$treatment,
                              latitude = MSAPn$lat,
                              populationID = MSAPn$populationID,
                              maternal_line = MSAPn$maternal_line); tibble(df_LogMM_loc176)
# add MEMGENE variables and additional factors
df_LogMM_loc176 <- tibble(merge(df_LogMM_loc176,
                                MEMGENEs,
                                by="latitude")); df_LogMM_loc176
# find minimum to shift values into positive space for model convergence
loc176_minValue <- abs(min(c(scale(df_LogMM_loc176$MEMGENE1),
                             scale(df_LogMM_loc176$MEMGENE2),
                             scale(df_LogMM_loc176$MEMGENE3)))) + 0.1; loc176_minValue
# add transformed MEMGENE variables
df_LogMM_loc176$MEMG1_rescaled <- scale(df_LogMM_loc176$MEMGENE1+loc176_minValue)^2
df_LogMM_loc176$MEMG2_rescaled <- scale(df_LogMM_loc176$MEMGENE2)+loc176_minValue
df_LogMM_loc176$MEMG3_rescaled <- scale(df_LogMM_loc176$MEMGENE3)+loc176_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc176$pop_ind <- paste0(df_LogMM_loc176$maternal_line, '_',
                                  df_LogMM_loc176$populationID)
# change variables to factors
df_LogMM_loc176$pop_ind <- as.factor(df_LogMM_loc176$pop_ind)
df_LogMM_loc176

#' ## Model
#' <a href="#top">Back to top</a>
#+ project_model.loc176.model
########### Model ####
# logistic mixed effects model
logMM.loc176 <- glmer(loc176 ~
                        MEMG1_rescaled +
                        treatment +
                        MEMG1_rescaled:treatment +
                        MEMG2_rescaled +
                        MEMG2_rescaled:treatment +
                        MEMG3_rescaled +
                        MEMG3_rescaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link = "logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc176); summary(logMM.loc176)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc176.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc176_BoxTidwell <- glmer(loc176 ~
                                   # fixed factors in model:
                                   MEMG1_rescaled +
                                   treatment +
                                   MEMG1_rescaled:treatment +
                                   MEMG2_rescaled +
                                   MEMG2_rescaled:treatment +
                                   MEMG3_rescaled +
                                   MEMG3_rescaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   MEMG1_rescaled:log(MEMG1_rescaled) +
                                   MEMG2_rescaled:log(MEMG2_rescaled) +
                                   MEMG3_rescaled:log(MEMG3_rescaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 # settings:
                                 family=binomial(link = "logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc176); summary(logMM.loc176_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc176_noInteractions <- update(logMM.loc176,
                                      .~.-MEMG1_rescaled:treatment
                                      -MEMG2_rescaled:treatment
                                      -MEMG3_rescaled:treatment)
# check removal
summary(logMM.loc176_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc176)
# check multicollinearity without interactions
check_collinearity(logMM.loc176_noInteractions) # low correlation
# 4. check for influential values (takes 15 minutes on a regular laptop)
logMM.loc176_inf <- influence.ME::influence(logMM.loc176,
                                            obs=T,
                                            delete=T); logMM.loc176_inf
logMM.loc176_cooks <- influence.ME::cooks.distance.estex(logMM.loc176_inf); logMM.loc176_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc176_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc176.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc176_evalX <- drop1(logMM.loc176,
                            test="Chisq"); logMM.loc176_evalX
# remove interactions
logMM.loc176_main <- update(logMM.loc176,
                            .~.-lat_scaled:treatment -
                              MEMG1_rescaled:treatment -
                              MEMG2_rescaled:treatment -
                              MEMG3_rescaled:treatment); summary(logMM.loc176_main)
# evaluate main model without interactions
logMM.loc176_evalmain <- drop1(logMM.loc176_main,
                               test="Chisq"); logMM.loc176_evalmain

#' # Loc222 (MSAP-n)
#' <a href="#top">Back to top</a>
#+ project_model.loc222
########### Loc222 (MSAPu) .......... ####
autocorr_candidates; autocorr_candidates[[2,3]]
# extract from AFLP data
df_LogMM_loc222 <- data.frame(loc222 = MSAPn[,autocorr_candidates[[2,3]]],
                              block = MSAPn$common_garden_block,
                              treatment = MSAPn$treatment,
                              latitude = MSAPn$lat,
                              populationID = MSAPn$populationID,
                              maternal_line = MSAPn$maternal_line); tibble(df_LogMM_loc222)
# add MEMGENE variables and additional factors
df_LogMM_loc222 <- tibble(merge(df_LogMM_loc222,
                                MEMGENEs,
                                by="latitude")); df_LogMM_loc222
# find minimum to shift values into positive space for model convergence
loc222_minValue <- abs(min(c(scale(df_LogMM_loc222$MEMGENE1),
                             scale(df_LogMM_loc222$MEMGENE2),
                             scale(df_LogMM_loc222$MEMGENE3)))) + 0.1; loc222_minValue
# add transformed MEMGENE variables
df_LogMM_loc222$MEMG1_rescaled <- scale(df_LogMM_loc222$MEMGENE1)+loc222_minValue
df_LogMM_loc222$MEMG2_rescaled <- scale(df_LogMM_loc222$MEMGENE2)+loc222_minValue
df_LogMM_loc222$MEMG3_rescaled <- scale(df_LogMM_loc222$MEMGENE3)+loc222_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc222$pop_ind <- paste0(df_LogMM_loc222$maternal_line,'_',
                                  df_LogMM_loc222$populationID)
# change variables to factors
df_LogMM_loc222$pop_ind <- as.factor(df_LogMM_loc222$pop_ind)
df_LogMM_loc222

#' ## Model
#' <a href="#top">Back to top</a>
#+ project_model.loc222.model
########### Model ####
# logistic mixed effects model
logMM.loc222 <- glmer(loc222 ~
                        MEMG1_rescaled +
                        treatment +
                        MEMG1_rescaled:treatment +
                        MEMG2_rescaled +
                        MEMG2_rescaled:treatment +
                        MEMG3_rescaled +
                        MEMG3_rescaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link = "logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc222); summary(logMM.loc222)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc222.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc222_BoxTidwell <- glmer(loc222 ~
                                   # fixed factors in model:
                                   MEMG1_rescaled +
                                   treatment +
                                   MEMG1_rescaled:treatment +
                                   MEMG2_rescaled +
                                   MEMG2_rescaled:treatment +
                                   MEMG3_rescaled +
                                   MEMG3_rescaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   MEMG1_rescaled:log(MEMG1_rescaled) +
                                   MEMG2_rescaled:log(MEMG2_rescaled) +
                                   MEMG3_rescaled:log(MEMG3_rescaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 # settings:
                                 family=binomial(link = "logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc222); summary(logMM.loc222_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc222_noInteractions <- update(logMM.loc222,
                                      .~.-MEMG1_rescaled:treatment
                                      -MEMG2_rescaled:treatment
                                      -MEMG3_rescaled:treatment)
# check removal
summary(logMM.loc222_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc222)
# check multicollinearity without interactions
check_collinearity(logMM.loc222_noInteractions) # low correlation
# 4. check for influential values (takes 15 minutes on a regular laptop)
logMM.loc222_inf <- influence.ME::influence(logMM.loc222,
                                            obs=T,
                                            delete=T); logMM.loc222_inf
logMM.loc222_cooks <- influence.ME::cooks.distance.estex(logMM.loc222_inf); logMM.loc222_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc222_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc222.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc222_evalX <- drop1(logMM.loc222,
                            test="Chisq"); logMM.loc222_evalX
# remove interactions
logMM.loc222_main <- update(logMM.loc222,
                            .~.-lat_scaled:treatment
                              -MEMG1_rescaled:treatment
                              -MEMG2_rescaled:treatment
                              -MEMG3_rescaled:treatment); summary(logMM.loc222_main)
# evaluate main model without interactions
logMM.loc222_evalmain <- drop1(logMM.loc222_main,
                               test="Chisq"); logMM.loc222_evalmain

#' # Loc135 (MSAP-n)
#' <a href="#top">Back to top</a>
#+ project_model.loc135
########### Loc135 (MSAPu) .......... ####
autocorr_candidates; autocorr_candidates[[3,3]]
# extract from AFLP data
df_LogMM_loc135 <- data.frame(loc135 = MSAPn[,autocorr_candidates[[3,3]]],
                              block = MSAPn$common_garden_block,
                              treatment = MSAPn$treatment,
                              latitude = MSAPn$lat,
                              populationID = MSAPn$populationID,
                              maternal_line = MSAPn$maternal_line); tibble(df_LogMM_loc135)
# add MEMGENE variables and additional factors
df_LogMM_loc135 <- tibble(merge(df_LogMM_loc135,
                                MEMGENEs,
                                by="latitude")); df_LogMM_loc135
# find minimum to shift values into positive space for model convergence
loc135_minValue <- abs(min(c(scale(df_LogMM_loc135$MEMGENE1),
                             scale(df_LogMM_loc135$MEMGENE2),
                             scale(df_LogMM_loc135$MEMGENE3)))) + 0.1; loc135_minValue
# add transformed MEMGENE variables
df_LogMM_loc135$MEMG1_rescaled <- scale(df_LogMM_loc135$MEMGENE1)+loc135_minValue
df_LogMM_loc135$MEMG2_rescaled <- scale(df_LogMM_loc135$MEMGENE2)+loc135_minValue
df_LogMM_loc135$MEMG3_rescaled <- scale(df_LogMM_loc135$MEMGENE3)+loc135_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc135$pop_ind <- paste0(df_LogMM_loc135$maternal_line,'_',
                                  df_LogMM_loc135$populationID)
# change variables to factors
df_LogMM_loc135$pop_ind <- as.factor(df_LogMM_loc135$pop_ind)
df_LogMM_loc135

#' ## Model
#' <a href="#top">Back to top</a>
#+ project_model.loc135.model
########### Model ####
# logistic mixed effects model
logMM.loc135 <- glmer(loc135 ~
                        MEMG1_rescaled +
                        treatment +
                        MEMG1_rescaled:treatment +
                        MEMG2_rescaled +
                        MEMG2_rescaled:treatment +
                        MEMG3_rescaled +
                        MEMG3_rescaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link = "logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc135); summary(logMM.loc135)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc135.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc135_BoxTidwell <- glmer(loc135 ~
                                   # fixed factors in model:
                                   MEMG1_rescaled +
                                   treatment +
                                   MEMG1_rescaled:treatment +
                                   MEMG2_rescaled +
                                   MEMG2_rescaled:treatment +
                                   MEMG3_rescaled +
                                   MEMG3_rescaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   MEMG1_rescaled:log(MEMG1_rescaled) +
                                   MEMG2_rescaled:log(MEMG2_rescaled) +
                                   MEMG3_rescaled:log(MEMG3_rescaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 # settings:
                                 family=binomial(link = "logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc135); summary(logMM.loc135_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc135_noInteractions <- update(logMM.loc135, .~.-MEMG1_rescaled:treatment
                                      -MEMG2_rescaled:treatment
                                      -MEMG3_rescaled:treatment)
# check removal
summary(logMM.loc135_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc135)
# check multicollinearity without interactions
check_collinearity(logMM.loc135_noInteractions) # low correlation
# 4. check for influential values (takes 15 minutes on a regular laptop)
logMM.loc135_inf <- influence.ME::influence(logMM.loc135,
                                            obs=T,
                                            delete=T); logMM.loc135_inf
logMM.loc135_cooks <- influence.ME::cooks.distance.estex(logMM.loc135_inf); logMM.loc135_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc135_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc135.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc135_evalX <- drop1(logMM.loc135,
                            test="Chisq"); logMM.loc135_evalX
# remove interactions
logMM.loc135_main <- update(logMM.loc135,
                            .~.-lat_scaled:treatment
                              -MEMG1_rescaled:treatment
                              -MEMG2_rescaled:treatment
                              -MEMG3_rescaled:treatment); summary(logMM.loc135_main)
# evaluate main model without interactions
logMM.loc135_evalmain <- drop1(logMM.loc135_main,
                               test="Chisq"); logMM.loc135_evalmain

#' # Results
#' <a href="#top">Back to top</a>
#+ project_results
########### Results .......................... ####
Autocorr_LRT_results <- rbind(data.frame(logMM.loc282_evalX,
                                         term = row.names(logMM.loc282_evalX)),
                              data.frame(logMM.loc282_evalmain,
                                         term = row.names(logMM.loc282_evalmain)),
                              data.frame(logMM.loc176_evalX,
                                         term = row.names(logMM.loc176_evalX)),
                              data.frame(logMM.loc176_evalmain,
                                         term = row.names(logMM.loc176_evalmain)),
                              data.frame(logMM.loc222_evalX,
                                         term = row.names(logMM.loc222_evalX)),
                              data.frame(logMM.loc135_evalmain,
                                         term = row.names(logMM.loc222_evalmain)),
                              data.frame(logMM.loc135_evalX,
                                         term = row.names(logMM.loc135_evalX)),
                              data.frame(logMM.loc135_evalmain,
                                         term = row.names(logMM.loc135_evalmain))); Autocorr_LRT_results
row.names(Autocorr_LRT_results) <- c(1:length(row.names(Autocorr_LRT_results))); Autocorr_LRT_results
Autocorr_LRT_results$marker <- c(rep("loc282",9),
                                 rep("loc176",9),
                                 rep("loc222",9),
                                 rep("loc135",9)); Autocorr_LRT_results
# add FDR
Autocorr_LRT_results$FDR <- NULL
Autocorr_LRT_results$FDR[1:9] <- p.adjust(Autocorr_LRT_results$Pr.Chi.[1:9],"fdr") # loc282
Autocorr_LRT_results$FDR[10:18] <- p.adjust(Autocorr_LRT_results$Pr.Chi.[10:18], "fdr") # loc176
Autocorr_LRT_results$FDR[19:27] <- p.adjust(Autocorr_LRT_results$Pr.Chi.[19:27], "fdr") # loc222
Autocorr_LRT_results$FDR[28:36] <- p.adjust(Autocorr_LRT_results$Pr.Chi.[28:36], "fdr") # loc135
Autocorr_LRT_results; tibble(Autocorr_LRT_results) # 27 7
# re-order columns
Autocorr_LRT_results <- Autocorr_LRT_results[,c(5,6,2,3,4,7)]
# re-name the <none> rows
Autocorr_LRT_results[c(1,10,19,28),1] <- "Full_model"
Autocorr_LRT_results[c(5,14,23,32),1] <- "Main_model"
tibble(Autocorr_LRT_results)
# save LRTs
write.table(Autocorr_LRT_results,
            "Data_logMM_Autocorr_results_LRT.txt",
            row.names=F)
# save models
LogMM_Autocorr.model_list <- list(tidy(logMM.loc282),
                                  tidy(logMM.loc176),
                                  tidy(logMM.loc222),
                                  tidy(logMM.loc135)); LogMM_Autocorr.model_list
names(LogMM_Autocorr.model_list) <- c("loc282", "loc176",
                                      "loc222", "loc135"); LogMM_Autocorr.model_list
# and export
excel_export(x=LogMM_Autocorr.model_list,
             file = 'Data_logMM_Autocorr_results_models.xlsx',
             table_names=names(LogMM_Autocorr.model_list))
# calculate pseudo-R-squared and AICc
logMM.loc282.R2 <- r.squaredGLMM(logMM.loc282); logMM.loc282.R2
logMM.loc176.R2 <- r.squaredGLMM(logMM.loc176); logMM.loc176.R2
logMM.loc222.R2 <- r.squaredGLMM(logMM.loc222); logMM.loc222.R2
logMM.loc135.R2 <- r.squaredGLMM(logMM.loc135); logMM.loc135.R2
# combine
logMM.Autocorr.R2 <- data.frame(Locus = c("loc282", "loc176","loc222","loc135"),
                                model = rep("logMM", 4),
                                AICc = c(AICc(logMM.loc282),AICc(logMM.loc176),
                                         AICc(logMM.loc222),AICc(logMM.loc135)),
                                R2m = c(logMM.loc282.R2[2,1],logMM.loc176.R2[2,1],
                                        logMM.loc222.R2[2,1],logMM.loc135.R2[2,1]),
                                R2c = c(logMM.loc282.R2[2,2],logMM.loc176.R2[2,2],
                                        logMM.loc222.R2[2,2],logMM.loc135.R2[2,2])); tibble(logMM.Autocorr.R2)
# save
write.table(logMM.Autocorr.R2,
            "Data_logMM_Autocorr_results_R2.txt", row.names=F)

#' # Session info
#' <a href="#top">Back to top</a>
#+ Session.info
sessionInfo()
#' <a href="#top">Back to top</a>
######## Session info .................. ####