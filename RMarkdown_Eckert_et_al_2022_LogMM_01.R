#' ---
#' title: <center><b>Markdown document from&colon;</b><br>Traces of Genetic but Not Epigenetic Adaptation in the Invasive Goldenrod _Solidago canadensis_ Despite the Absence of Population Structure</center>
#' pagetitle: RMarkdown document from:&nbsp;Eckert&nbsp;et&nbsp;al.&nbsp;(2022)
#' subtitle: <center>doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.3389/fevo.2022.856453">10.3389/fevo.2022.856453</a></center>
#' author: <center>Eckert, S., Herden, J., Stift, M., Durka, W., van Kleunen, M., & Joshi, J.</center>
#' date: <center>`r Sys.Date()`</center>
#' abstract: <p align="justify">This RMarkdown script belongs
#'   to a series of scripts generated by Silvia Eckert as part of
#'   the statistical analysis for the above-mentioned manuscript.
#'   The data underlying the applied R code can be found in the ZENODO
#'   repository and contains genetic (AFLP) and epigenetic (MSAP) markers
#'   from offspring of 25 _Solidago canadensis_ populations sampled along a
#'   latitudinal gradient in Central Europe. This particular RMarkdown script
#'   is part 01/03 and applies logistic mixed-effects models on AFLP and MSAP
#'   datasets. <b>Please cite this
#'   script as follows:</b></p><br><p>Eckert, S., Herden, J.,
#'   Stift, M., Durka, W., van Kleunen, M., & Joshi, J. (2022). Data From&colon;
#'   Traces of Genetic but Not Epigenetic Adaptation in the Invasive
#'   Goldenrod _Solidago canadensis_ Despite the Absence of Population
#'   Structure. _Zenodo_. doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.5281/zenodo.6388135">10.5281/zenodo.6388135</a></center></p>
#' geometry: margin=2cm
#' output:
#'   html_document:
#'      code_folding: show
#'      keep_md: FALSE
#'      theme: flatly
#'      highlight: textmate
#'      df_print: paged
#'      toc: true
#'      toc_float: true
#' ---
#' 

#'
#'```{r setup, include = FALSE}
#'knitr::opts_chunk$set(eval=FALSE, cache=FALSE, warning=FALSE)
#'```

#' # Packages
#' <a href="#top">Back to top</a>
#+ project_packages, results='hide', message=FALSE, warning=FALSE
########### packages ...................... ####
# install.packages("name_of_package") # install necessary packages
# install knitr to save this script as html output using RStudio with Ctrl+Shift+K (Windows & Linux) or Command+Shift+K (macOS)
# install.packages("knitr") 
# getwd() # get current working directory
# setwd() # set working directory
# create folder for datasets to be stored to get this RMarkdown script running
dir.create("./data",
           showWarnings=F)
# add necessary libraries
library(lme4)
library(ggplot2)
library(cowplot)
library(tibble)
library(tidyr)
library(dplyr)
library(xlsx)
library(ImportExport)
library(sjmisc)
library(ggeffects)
library(broom.mixed)
library(MuMIn)
library(optimx)
library(dfoptim)
library(easystats)

#' # Load data
#' <a href="#top">Back to top</a>
#+ project_load.data
########### load data ....................... ####
# load AFLP/MSAP data
source("RMarkdown_Eckert_et_al_2022_loadMolecularData.R")

#' ## PCA
#' <a href="#top">Back to top</a>
#+ project_distances.pca
######## WorldClim PCA ####
PCA_axes <- tibble(read.table("./data/Data_PCA_WorldClim.txt",
                              header=T)); PCA_axes
colnames(PCA_axes)[4] <- "latitude" # re-label for merging

#' ## Outlier
#+ project_load.outlier
######## Outlier loci ####
# climate
# loc58 (AFLP), loc286 (AFLP), loc189 (MSAP-m)
climate_candidates <- tibble(read.table("./data/Data_OutlierScan_Climate_intersection.txt",
                                        header=T)); climate_candidates

#' # Loc58 (AFLP)
#' <a href="#top">Back to top</a>
#+ project_model.loc58
########### Loc58 (AFLP) ................ ####
climate_candidates; climate_candidates[[1,1]]
# extract from AFLP data
df_LogMM_loc58 <- data.frame(loc58=AFLP[,climate_candidates[[1,1]]],
                             block=AFLP$common_garden_block,
                             treatment=AFLP$treatment,
                             latitude=AFLP$lat,
                             populationID=AFLP$populationID,
                             maternal_line=AFLP$maternal_line); tibble(df_LogMM_loc58)
# add PCA axes
df_LogMM_loc58 <- tibble(merge(df_LogMM_loc58,
                               PCA_axes,
                               by="latitude")); df_LogMM_loc58
# find minimum to shift values into positive space for model convergence
loc58_minValue <- abs(min(c(scale(df_LogMM_loc58$PC1),
                            scale(df_LogMM_loc58$PC2)))) + 0.1; loc58_minValue
# add transformed MEMGENE variables
df_LogMM_loc58$PC1_scaled <- scale(df_LogMM_loc58$PC1)+loc58_minValue
df_LogMM_loc58$PC2_scaled <- scale(df_LogMM_loc58$PC2)+loc58_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc58$pop_ind <- paste0(df_LogMM_loc58$maternal_line,'_',
                                 df_LogMM_loc58$populationID)
# change variables to factors
df_LogMM_loc58$pop_ind <- as.factor(df_LogMM_loc58$pop_ind)
df_LogMM_loc58

#' ## Mixed model
#' <a href="#top">Back to top</a>
#+ project_model.loc58.model
########### Model ####
# logistic mixed effects model
logMM.loc58 <- glmer(loc58 ~
                       PC1_scaled + treatment +
                       PC1_scaled:treatment +
                       PC2_scaled +
                       PC2_scaled:treatment +
                       (1|populationID) +
                       (1|pop_ind),
                     family=binomial(link="logit"),
                     control=glmerControl(optimizer="optimx",
                                          optCtrl=list(method="nlminb")),
                     data=df_LogMM_loc58); summary(logMM.loc58)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc58.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc58_BoxTidwell <- glmer(loc58 ~
                                  PC1_scaled +
                                  treatment +
                                  PC1_scaled:treatment +
                                  PC2_scaled +
                                  PC2_scaled:treatment +
                                  # Box-Tidwell test on linearity in logistic regression:
                                  PC1_scaled:log(PC1_scaled) +
                                  PC2_scaled:log(PC2_scaled) +
                                  # random factors in model:
                                  (1|populationID) +
                                  (1|pop_ind),
                                family=binomial(link="logit"),
                                control=glmerControl(optimizer="optimx",
                                                     optCtrl=list(method="nlminb")),
                                data=df_LogMM_loc58); summary(logMM.loc58_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc58_noInteractions <- update(logMM.loc58,.~.-PC1_scaled:treatment
                                     -PC2_scaled:treatment)
# check model with removed terms
summary(logMM.loc58_noInteractions)$vcov@Dimnames[1]
# check model with interactions for comparison
check_collinearity(logMM.loc58)
# check multicollinearity without interactions
check_collinearity(logMM.loc58_noInteractions)
# 4. check for influential values (takes 15 minutes on a regular laptop)
logMM.loc58_inf <- influence.ME::influence(logMM.loc58,
                                           obs=T,
                                           delete=T); logMM.loc58_inf
logMM.loc58_cooks <- influence.ME::cooks.distance.estex(logMM.loc58_inf); logMM.loc58_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc58_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc58.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc58_evalX <- drop1(logMM.loc58,
                           test="Chisq"); logMM.loc58_evalX
# remove interactions
logMM.loc58_main <- update(logMM.loc58,.~.-PC1_scaled:treatment-
                             PC2_scaled:treatment); summary(logMM.loc58_main)
# evaluate main model without interactions
logMM.loc58_evalmain <- drop1(logMM.loc58_main,
                              test="Chisq"); logMM.loc58_evalmain

#' # Loc286 (AFLP)
#' <a href="#top">Back to top</a>
#+ project_model.loc286
########### Loc286 (AFLP) .............. ####
climate_candidates; climate_candidates[[2,1]]
# extract from AFLP data
df_LogMM_loc286 <- data.frame(loc286=AFLP[,climate_candidates[[2,1]]],
                              block=AFLP$common_garden_block,
                              treatment=AFLP$treatment,
                              latitude=AFLP$lat,
                              populationID=AFLP$populationID,
                              maternal_line=AFLP$maternal_line); tibble(df_LogMM_loc286)
# add PCA axes
df_LogMM_loc286 <- tibble(merge(df_LogMM_loc286,
                                PCA_axes,
                                by="latitude")); df_LogMM_loc286
# find minimum to shift values into positive space for model convergence
loc286_minValue <- abs(min(c(scale(df_LogMM_loc286$PC2),
                             scale(df_LogMM_loc286$PC1)))) + 0.1; loc286_minValue
# add transformed MEMGENE variables
df_LogMM_loc286$PC1_scaled <- scale(rank(df_LogMM_loc286$PC1))+loc286_minValue
df_LogMM_loc286$PC2_scaled <- scale(rank(df_LogMM_loc286$PC2))+loc286_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc286$pop_ind <- paste0(df_LogMM_loc286$maternal_line,'_',
                                  df_LogMM_loc286$populationID)
# change variables to factors
df_LogMM_loc286$pop_ind <- as.factor(df_LogMM_loc286$pop_ind)
df_LogMM_loc286

#' ## Mixed model
#' <a href="#top">Back to top</a>
#+ project_model.loc286.model
########### Model ####
# logistic mixed effects model
logMM.loc286 <- glmer(loc286 ~
                        PC1_scaled +
                        treatment +
                        PC1_scaled:treatment +
                        PC2_scaled +
                        PC2_scaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link="logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc286); summary(logMM.loc286)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc286.glmer_assumptions
########### Assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc286_BoxTidwell <- glmer(loc286 ~
                                   PC1_scaled +
                                   treatment +
                                   PC1_scaled:treatment +
                                   PC2_scaled +
                                   PC2_scaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   PC1_scaled:log(PC1_scaled) +
                                   PC2_scaled:log(PC2_scaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 family=binomial(link="logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc286); summary(logMM.loc286_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc286_noInteractions <- update(logMM.loc286,.~.-PC1_scaled:treatment
                                      -PC2_scaled:treatment)
# check removal
summary(logMM.loc286_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc286)
# check multicollinearity without interactions
check_collinearity(logMM.loc286_noInteractions)
# 4. check for influential values (takes 15 minutes)
logMM.loc286_inf <- influence.ME::influence(logMM.loc286,
                                            obs=T,
                                            delete=T); logMM.loc286_inf
logMM.loc286_cooks <- influence.ME::cooks.distance.estex(logMM.loc286_inf); logMM.loc286_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc286_cooks>1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc286.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc286_evalX <- drop1(logMM.loc286,
                            test="Chisq"); logMM.loc286_evalX
# remove interactions
logMM.loc286_main <- update(logMM.loc286,.~.-PC1_scaled:treatment -
                              PC2_scaled:treatment); summary(logMM.loc286_main)
# evaluate main model without interactions
logMM.loc286_evalmain <- drop1(logMM.loc286_main,
                               test="Chisq"); logMM.loc286_evalmain

#' # Loc189 (MSAP-m)
#' <a href="#top">Back to top</a>
#+ project_model.loc189
########### Loc189 (MSAP-m) ........ ####
climate_candidates; climate_candidates[[1,2]]
# extract from AFLP data
df_LogMM_loc189 <- data.frame(loc189=MSAPm[,climate_candidates[[1,2]]],
                              block=MSAPm$common_garden_block,
                              treatment=MSAPm$treatment,
                              latitude=MSAPm$lat,
                              populationID=MSAPm$populationID,
                              maternal_line=MSAPm$maternal_line); tibble(df_LogMM_loc189)
# add PCA axes
df_LogMM_loc189 <- tibble(merge(df_LogMM_loc189,
                                PCA_axes,
                                by="latitude")); df_LogMM_loc189
# find minimum to shift values into positive space for model convergence
loc189_minValue <- abs(min(c(scale(df_LogMM_loc189$PC2),
                             scale(df_LogMM_loc189$PC3)))) + 0.1; loc189_minValue
# add transformed MEMGENE variables
df_LogMM_loc189$PC2_scaled <- scale(df_LogMM_loc189$PC2)+loc189_minValue
df_LogMM_loc189$PC3_scaled <- scale(df_LogMM_loc189$PC3)+loc189_minValue
# add nested dummy variable (maternal line nested in population)
df_LogMM_loc189$pop_ind <- paste0(df_LogMM_loc189$maternal_line,'_',
                                  df_LogMM_loc189$populationID)
# change variables to factors
df_LogMM_loc189$pop_ind <- as.factor(df_LogMM_loc189$pop_ind)
df_LogMM_loc189

#' ## Model
#' <a href="#top">Back to top</a>
#+ project_model.loc189.glmer
########### Model ####
# logistic mixed effects model
logMM.loc189 <- glmer(loc189 ~
                        PC2_scaled +
                        treatment +
                        PC2_scaled:treatment +
                        PC3_scaled +
                        PC3_scaled:treatment +
                        (1|populationID) +
                        (1|pop_ind),
                      family=binomial(link="logit"),
                      control=glmerControl(optimizer="optimx",
                                           optCtrl=list(method="nlminb")),
                      data=df_LogMM_loc189); summary(logMM.loc189)

#' ## Assumptions
#' <a href="#top">Back to top</a>
#+ project_model.loc189.glmer_assumptions
########### assumptions ####
# 1. outcome should be binary
# This is naturally the case with presence/absence response variables from AFLP/MSAP data
# 2. linearity in the logit for any indepenent variable (checked with Box-Tidwell method)
# add Box-Tidwell transformed predictor variables to model (should be non-significant!)
# Box-Tidwell transformed predictor: explanatory_variable x log(explanatory_variable)
logMM.loc189_BoxTidwell <- glmer(loc189 ~
                                   PC2_scaled +
                                   treatment +
                                   PC2_scaled:treatment +
                                   PC3_scaled +
                                   PC3_scaled:treatment +
                                   # Box-Tidwell test on linearity in logistic regression:
                                   PC2_scaled:log(PC2_scaled) +
                                   PC3_scaled:log(PC3_scaled) +
                                   # random factors in model:
                                   (1|populationID) +
                                   (1|pop_ind),
                                 family=binomial(link="logit"),
                                 control=glmerControl(optimizer="optimx",
                                                      optCtrl=list(method="nlminb")),
                                 data=df_LogMM_loc189); summary(logMM.loc189_BoxTidwell)
# 3. check multicollinearity (should be below 4 or 10)
# check for model without interaction terms
logMM.loc189_noInteractions <- update(logMM.loc189,.~.-PC2_scaled:treatment
                                      -PC3_scaled:treatment)
# check removal
summary(logMM.loc189_noInteractions)$vcov@Dimnames[1]
# check with interactions for comparison
check_collinearity(logMM.loc189)
# check multicollinearity without interactions
check_collinearity(logMM.loc189_noInteractions)
# 4. check for influential values (takes 15 minutes)
logMM.loc189_inf <- influence.ME::influence(logMM.loc189,
                                            obs=T,
                                            delete=T); logMM.loc189_inf
logMM.loc189_cooks <- influence.ME::cooks.distance.estex(logMM.loc189_inf); logMM.loc189_cooks
# show influential values (Cook's distance values > 1 are influential)
which(logMM.loc189_cooks > 1)

#' ## Likelihood-ratio tests
#' <a href="#top">Back to top</a>
#+ project_model.loc189.LRT
########### LRT ####
# evaluate model against model without interactions
logMM.loc189_evalX <- drop1(logMM.loc189,
                            test="Chisq"); logMM.loc189_evalX
# remove interactions
logMM.loc189_main <- update(logMM.loc189,.~. -PC2_scaled:treatment -
                              PC3_scaled:treatment); summary(logMM.loc189_main)
# evaluate main model without interactions
logMM.loc189_evalmain <- drop1(logMM.loc189_main,
                               test="Chisq"); logMM.loc189_evalmain

#' # Results
#' <a href="#top">Back to top</a>
#+ project_results
########### Results .......................... ####
Clim_LRT_results <- rbind(data.frame(logMM.loc58_evalX,
                                     term=row.names(logMM.loc58_evalX)),
                          data.frame(logMM.loc58_evalmain,
                                     term=row.names(logMM.loc58_evalmain)),
                          data.frame(logMM.loc286_evalX,
                                     term=row.names(logMM.loc286_evalX)),
                          data.frame(logMM.loc286_evalmain,
                                     term=row.names(logMM.loc286_evalmain)),
                          data.frame(logMM.loc189_evalX,
                                     term=row.names(logMM.loc189_evalX)),
                          data.frame(logMM.loc189_evalmain,
                                     term=row.names(logMM.loc189_evalmain))); Clim_LRT_results
row.names(Clim_LRT_results) <- c(1:length(row.names(Clim_LRT_results))); Clim_LRT_results
Clim_LRT_results$marker <- c(rep("loc58",7),
                             rep("loc286",7),
                             rep("loc189",7)); Clim_LRT_results
# add FDR
Clim_LRT_results$FDR <- NULL
Clim_LRT_results$FDR[1:7] <- p.adjust(Clim_LRT_results$Pr.Chi.[1:7],"fdr") # loc58
Clim_LRT_results$FDR[8:14] <- p.adjust(Clim_LRT_results$Pr.Chi.[8:14],"fdr") # loc286
Clim_LRT_results$FDR[15:21] <- p.adjust(Clim_LRT_results$Pr.Chi.[15:21],"fdr") # loc189
Clim_LRT_results; tibble(Clim_LRT_results)
# re-order columns
Clim_LRT_results <- Clim_LRT_results[,c(5,6,2,3,4,7)]
# re-name the <none> rows
Clim_LRT_results[c(1,8,15),1] <- "Full_model"
Clim_LRT_results[c(4,11,18),1] <- "Main_model"
tibble(Clim_LRT_results)
# save LRTs
write.table(Clim_LRT_results,
            "Data_logMM_Climate_results_LRT.txt",
            row.names=F)
# save models
LogMM_Clim.model_list <- list(tidy(logMM.loc58),
                              tidy(logMM.loc286),
                              tidy(logMM.loc189)); LogMM_Clim.model_list
names(LogMM_Clim.model_list) <- c("loc58","loc286","loc189"); LogMM_Clim.model_list
# and export
excel_export(x=LogMM_Clim.model_list,
             file='Data_logMM_Climate_results_models.xlsx',
             table_names=names(LogMM_Clim.model_list))
# calculate pseudo-R-squared and AICc
logMM.loc58.R2 <- r.squaredGLMM(logMM.loc58); logMM.loc58.R2
logMM.loc286.R2 <- r.squaredGLMM(logMM.loc286); logMM.loc286.R2
logMM.loc189.R2 <- r.squaredGLMM(logMM.loc189); logMM.loc189.R2
# combine
logMM.Clim.R2 <- data.frame(Locus=c("loc58","loc286","loc189"),
                            model=rep("logMM",3),
                            AICc=c(AICc(logMM.loc58),AICc(logMM.loc286),
                                     AICc(logMM.loc189)),
                            R2m=c(logMM.loc58.R2[2,1],logMM.loc286.R2[2,1],
                                    logMM.loc189.R2[2,1]),
                            R2c=c(logMM.loc58.R2[2,2],logMM.loc286.R2[2,2],
                                    logMM.loc189.R2[2,2])); tibble(logMM.Clim.R2)
# save
write.table(logMM.Clim.R2,
            "Data_logMM_Climate_results_R2.txt",
            row.names=F)

#' # Session info
#' <a href="#top">Back to top</a>
#+ Session.info
sessionInfo()
#' <a href="#top">Back to top</a>
######## Session info .................. ####