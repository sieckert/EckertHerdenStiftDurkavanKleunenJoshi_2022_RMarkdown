#' ---
#' title: <center><b>Markdown document from&colon;</b><br>Traces of Genetic but Not Epigenetic Adaptation in the Invasive Goldenrod _Solidago canadensis_ Despite the Absence of Population Structure</center>
#' pagetitle: RMarkdown document from:&nbsp;Eckert&nbsp;et&nbsp;al.&nbsp;(2022)
#' subtitle: <center>doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.3389/fevo.2022.856453">10.3389/fevo.2022.856453</a></center>
#' author: <center>Eckert, S., Herden, J., Stift, M., Durka, W., van Kleunen, M., & Joshi, J.</center>
#' date: <center>`r Sys.Date()`</center>
#' abstract: <p align="justify">This RMarkdown script belongs
#'   to a series of scripts generated by Silvia Eckert as part of
#'   the statistical analysis for the above-mentioned manuscript.
#'   The data underlying the applied R code can be found in the ZENODO
#'   repository and contains genetic (AFLP) and epigenetic (MSAP) markers
#'   from offspring of 25 _Solidago canadensis_ populations sampled along a
#'   latitudinal gradient in Central Europe. This particular RMarkdown script
#'   is part 01/06 and loads the AFLP and MSAP input data to use in the LEA genome-scan approach. <b>Please cite this
#'   script as follows:</b></p><br><p>Eckert, S., Herden, J.,
#'   Stift, M., Durka, W., van Kleunen, M., & Joshi, J. (2022). Data From&colon;
#'   Traces of Genetic but Not Epigenetic Adaptation in the Invasive
#'   Goldenrod _Solidago canadensis_ Despite the Absence of Population
#'   Structure. _Zenodo_. doi&colon; <a target="_blank" rel="noopener noreferrer" href="https://www.doi.org/10.5281/zenodo.6388135">10.5281/zenodo.6388135</a></center></p>
#' geometry: margin=2cm
#' output:
#'   html_document:
#'      code_folding: show
#'      keep_md: FALSE
#'      theme: flatly
#'      highlight: textmate
#'      df_print: paged
#'      toc: true
#'      toc_float: true
#' ---
#' 

#'
#'```{r setup, include = FALSE}
#'knitr::opts_chunk$set(eval=FALSE, cache=FALSE, warning=FALSE)
#'```

#' # Packages
#' <a href="#top">Back to top</a>
#+ project_packages, results='hide', message=FALSE, warning=FALSE
########### packages ...................... ####
# install.packages("name_of_package") # install necessary packages
# install knitr to save this script as html output using RStudio with Ctrl+Shift+K (Windows & Linux) or Command+Shift+K (macOS)
# install.packages("knitr") 
# getwd() # get current working directory
# setwd() # set working directory
# create folder for datasets to be stored to get this RMarkdown script running
dir.create("./data",
           showWarnings=F)
# add necessary libraries
library(fields)
library(RColorBrewer)
library(mapplots)
BiocManager::install("LEA")
library(LEA)
library(zvau)
library(tibble)
library(adegenet)
library(hierfstat)
library(poppr)
library(ggplot2)
library(cowplot) 
library(ggthemes)
library(ggrepel)
library(scales)
library(ggpubr)
library(qvalue)
library(forcats)

#' ## Functions
#' <a href="#top">Back to top</a>
#+ functions
########## functions ####
# Modified from write.bayescan() function in package hierfstat
writeBayeScan <- function (dat = dat, diploid = FALSE, fn = "dat.bsc") {
  nloc <- dim(dat)[2] - 1
  npop <- length(table(dat[, 1]))
  alc.dat <- allele.count(dat, diploid)
  alc.peaks <- lapply(alc.dat, tail, 1)
  nal <- unlist(lapply(alc.dat, function(x) dim(x)[1]))
  nindx <- sapply(alc.dat, function(x) apply(x, 2, sum))
  write(paste("[loci]=", nloc, sep = ""), fn)
  write("", fn, append = TRUE)
  write(paste("[populations]=", npop, sep = ""), 
        fn, append = TRUE)
  write("", fn, append = TRUE)
  
  for (ip in 1:npop) {
    write("", fn, append = TRUE)
    write(paste("[pop]=", ip, sep = ""), fn, 
          append = TRUE)
    for (il in 1:nloc) {
      tow <- c(il, nindx[ip],# il],
               #nal[il],
               alc.peaks[[il]][ip])
      write(tow, fn, append = TRUE, ncolumns = length(tow))
    }
  }
  print(cat("Data written in BayeScan format to file: ", fn))
}

#' # Load data
#' <a href="#top">Back to top</a>
#+ project_load.data
########### load data ....................... ####
# load AFLP/MSAP data
source("RMarkdown_Eckert_et_al_2022_loadMolecularData.R")

#' ## AFLP
#' <a href="#top">Back to top</a>
#+ project_load.AFLP
######## AFLP ####
# change to genind format
# presence/absence data (@type: PA)
AFLP.genind <- df2genind(AFLP[,-c(1:8)],
                         sep=",",
                         pop = AFLP$populationID,
                         ind = AFLP$uniqueID,
                         strata=AFLP[,c(1:8)],
                         ploidy = 2,
                         type = c("PA")); AFLP.genind
tibble(strata(AFLP.genind))
# subset to control plants
# presence/absence data (@type: PA)
AFLP_C <- AFLP[AFLP$treatment=='CON',]
AFLP_C.genind <- df2genind(AFLP_C[,-c(1:8)],
                           sep=",",
                           pop = AFLP_C$populationID,
                           ind.names = AFLP_C$uniqueID,
                           strata=AFLP_C[,c(1:8)],
                           ploidy = 2,
                           type = c("PA")); AFLP_C.genind
# convert to BayeScan format (for use with software BayeScan)
# for converting in bayescan format, only the population is used as meta data
AFLP_C.bayescan <- AFLP_C[,-c(1:6,8)]; names(AFLP_C.bayescan)
colnames(AFLP_C.bayescan)[1] <- c("pop"); AFLP_C.bayescan
# save
writeBayeScan(AFLP_C.bayescan,
              diploid=F,
              fn = "./data/Input_AFLP_C.bayescan") # takes about 1 minute
# convert to STRUCTURE format (as input for LEA)
writeStructure(AFLP_C.genind,
               file = "./data_LEA/Input_AFLP_C.struct")

#' ## MSAP-n
#' <a href="#top">Back to top</a>
#+ project_load.MSAPu
######## MSAP-n ####
# save as genind object
MSAPn.genind <- df2genind(MSAPn[,-c(1:8)],
                           sep=",",
                           pop = MSAPn$populationID,
                           ind = MSAPn$uniqueID,
                           strata=MSAPn[,c(1:8)],
                           ploidy = 2,
                           type = c("PA")); MSAPn.genind
# subset to control plants
# presence/absence data (@type: PA)
MSAPn_C <- MSAPn[MSAPn$treatment=='CON',]
MSAPn_C.genind <- df2genind(MSAPn_C[,-c(1:8)],
                             sep=",",
                             pop = MSAPn_C$populationID,
                             ind = MSAPn_C$uniqueID,
                             strata=MSAPn_C[,c(1:8)],
                             ploidy = 2,
                             type = c("PA")); MSAPn_C.genind
# convert to BayeScan format (as input for BayeScan software)
MSAPn_C.bayescan <- MSAPn_C[,-c(1:6,8)]; names(MSAPn_C.bayescan)
colnames(MSAPn_C.bayescan)[1] <- c("pop")
writeBayeScan(MSAPn_C.bayescan, diploid=F,
              fn = "./data/Input_MSAPu_C.bayescan")
# convert to STRUCTURE format (as input for LEA package)
writeStructure(MSAPn_C.genind,
               file = "./data_LEA/Input_MSAPu_C.struct")

#' ## MSAP-m
#' <a href="#top">Back to top</a>
#+ project_load.MSAPm
######## MSAP-m ####
# save as genind object
MSAPm.genind <- df2genind(MSAPm[,-c(1:8)],
                           sep=",",
                           pop = MSAPm$populationID,
                           ind = MSAPm$uniqueID,
                           strata=MSAPm[,c(1:8)],
                           ploidy = 2,
                           type = c("PA")); MSAPm.genind
# subset to control plants
# presence/absence data (@type: PA)
MSAPm_C <- MSAPm[MSAPm$treatment=='CON',]
MSAPm_C.genind <- df2genind(MSAPm_C[,-c(1:8)], sep=",",
                             pop = MSAPm_C$populationID,
                             ind = MSAPm_C$uniqueID, strata=MSAPm_C[,c(1:8)],
                             ploidy = 2, type = c("PA")); MSAPm_C.genind
# convert to BayeScan format
MSAPm_C.bayescan <- MSAPm_C[,-c(1:6,8)]; names(MSAPm_C.bayescan)
colnames(MSAPm_C.bayescan)[1] <- c("pop")
writeBayeScan(MSAPm_C.bayescan, diploid=F,
              fn = "./data/Input_MSAPm_C.bayescan")
# convert to STRUCTURE format (as input for LEA)
writeStructure(MSAPm_C.genind,
               file = "./data_LEA/Input_MSAPm_C.struct")

#' ## PCA
#' <a href="#top">Back to top</a>
#+ project_load.AFLP_pca
######## PCA ####
ClimData <- tibble(read.table("./data/Data_PCA_WorldClim.txt",
                              header=T)); ClimData
# AFLP
AFLP_C.strata <- AFLP_C.genind@strata[,c(1,5)]; tibble(AFLP_C.strata)
AFLP_C.strata$uniqueID <- as.character(AFLP_C.strata$uniqueID)
AFLP_C.strata$lat <- as.numeric(as.character(AFLP_C.strata$lat))
tibble(AFLP_C.strata)
AFLP_C.env <- merge(x=AFLP_C.strata,
                    y=ClimData,
                    by=c("lat")); tibble(AFLP_C.env)
# MSAP-m
MSAPm_C.strata <- MSAPm_C.genind@strata[,c(1,5)]; tibble(MSAPm_C.strata)
MSAPm_C.strata$uniqueID <- as.character(MSAPm_C.strata$uniqueID)
MSAPm_C.strata$lat <- as.numeric(as.character(MSAPm_C.strata$lat))
tibble(MSAPm_C.strata)
MSAPm_C.env <- merge(x=MSAPm_C.strata,
                      y=ClimData,
                      by=c("lat")); tibble(MSAPm_C.env)
# MSAP-n
MSAPn_C.strata <- MSAPn_C.genind@strata[,c(1,5)]; tibble(MSAPn_C.strata)
MSAPn_C.strata$uniqueID <- as.character(MSAPn_C.strata$uniqueID)
MSAPn_C.strata$lat <- as.numeric(as.character(MSAPn_C.strata$lat))
tibble(MSAPn_C.strata)
MSAPn_C.env <- merge(x=MSAPn_C.strata,
                      y=ClimData,
                      by=c("lat")); tibble(MSAPn_C.env)

#' # Environment
#' <a href="#top">Back to top</a>
#+ project_load.environment
######## environment .................. ####
# scaled and centered latitude as environmental variable
#' ## AFLP
#+ project_load.environment.AFLP
######## AFLP ####
# write environmental input for LFMM in LEA
# order: latitude, PC1, memgene1, memgene2, memgene3
# use PC1-3 from climate PCA as environmental variable
AFLP_C.env <- as.matrix(data.frame(PC1 = AFLP_C.env$PC1,
                                   PC2 = AFLP_C.env$PC2,
                                   PC3 = AFLP_C.env$PC3)); AFLP_C.env
write.env(AFLP_C.env,"./data_LEA/AFLP_C.env")

#' ## MSAP-n
#' <a href="#top">Back to top</a>
#+ project_load.environment.MSAPu
######## MSAP-n ####
# write environmental input for LFMM in LEA
# order: latitude, PC1, memgene1, memgene2, memgene3
# use PC1-3 from climate PCA as environmental variable
MSAPn_C.env <- as.matrix(data.frame(PC1 = MSAPn_C.env$PC1,
                                     PC2 = MSAPn_C.env$PC2,
                                     PC3 = MSAPn_C.env$PC3)); MSAPn_C.env
write.env(MSAPn_C.env,"./data_LEA/MSAPu_C.env")

#' ## MSAP-m
#' <a href="#top">Back to top</a>
#+ project_load.environment.MSAPm
######## MSAP-m ####
# write environmental input for LFMM in LEA
# order: latitude, PC1, memgene1, memgene2, memgene3
# use PC1-3 from climate PCA as environmental variable
MSAPm_C.env <- as.matrix(data.frame(PC1 = MSAPm_C.env$PC1,
                                     PC2 = MSAPm_C.env$PC2,
                                     PC3 = MSAPm_C.env$PC3)); MSAPm_C.env
write.env(MSAPm_C.env,"./data_LEA/MSAPm_C.env")

#' # Session info
#' <a href="#top">Back to top</a>
#+ Session.info
sessionInfo()
#' <a href="#top">Back to top</a>
######## Session info .................. ####
